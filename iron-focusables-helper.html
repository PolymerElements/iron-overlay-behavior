<!doctype html>
<!--
@license
Copyright (c) 2016 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<link rel="import" href="../polymer/polymer.html">

<script>
  (function() {
    'use strict';

    Polymer.IronFocusablesHelper = {
      /**
       * Returns the first and last tabbable nodes, excluding the root node.
       * It searches the tabbable nodes in the light and shadow dom of the chidren,
       * sorting the result by tabindex.
       * @param {!Node} node
       * @return {Array<HTMLElement>}
       */
      getTabbableNodes: function(node) {
        var tabbables = _getFirstLastTabbables(node);
        return tabbables ? _flattenFirstLastTabbables(tabbables) : [];
      },
      isFocusable: isFocusable,
      isTabbable: isTabbable
    };

    var isNativeShadowDOM = !window.ShadyDOM && !!Element.prototype.attachShadow;
    var p = Element.prototype;
    var matches = p.matches || p.matchesSelector || p.mozMatchesSelector ||
      p.msMatchesSelector || p.oMatchesSelector || p.webkitMatchesSelector;

    function _getFirstLastTabbables(root) {
      // Handle only Element and DocumentFragments.
      if (root.nodeType !== Node.ELEMENT_NODE && root.nodeType !== Node.DOCUMENT_FRAGMENT_NODE)
        return null;
      // Skip all tabbables inside a shadowRoot if element has tabindex = -1.
      if (isNativeShadowDOM && root.shadowRoot && root.getAttribute('tabindex') === '-1')
        return null;

      // Special treatment for <slot>, as we cannot use tree walkers for distributed content ;_;
      if (isNativeShadowDOM && root.tagName === 'SLOT') {
        var nodes = root.assignedNodes({
          flatten: true
        });
        var tabbables = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
          var node = nodes[i];
          if (node.nodeType !== Node.ELEMENT_NODE) continue;
          node.__firstLastTabbables = _getFirstLastTabbables(node);
          // Keep reference of this node in the slot's __firstLastTabbables.
          if (isTabbable(node) || node.__firstLastTabbables) {
            _updateFirstLast(node, tabbables);
          }
        }
        return tabbables.length ? tabbables : null;
      }

      var startNode = isNativeShadowDOM && root.shadowRoot ? root.shadowRoot : root;
      var walker = document.createTreeWalker(startNode, NodeFilter.SHOW_ELEMENT, {
        acceptNode: _shouldAcceptNode
      }, false);

      var tabbables = [];
      while (walker.nextNode()) {
        _updateFirstLast(walker.currentNode, tabbables);
      }
      return tabbables.length ? tabbables : null;
    }

    function _flattenFirstLastTabbables(tabbables) {
      // Get deepest first & last tabbables.
      var first = tabbables[0];
      while (first && first.__firstLastTabbables) {
        first = first.__firstLastTabbables[0];
      }
      var last = tabbables[tabbables.length - 1];
      while (last && last.__firstLastTabbables) {
        last = last.__firstLastTabbables[last.__firstLastTabbables.length - 1];
      }
      return last !== first ? [first, last] : [first];
    }

    function _shouldAcceptNode(element) {
      if (isNativeShadowDOM && element.shadowRoot || element.tagName === 'SLOT') {
        element.__firstLastTabbables = _getFirstLastTabbables(element);
        return element.__firstLastTabbables ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT;
      }
      return isTabbable(element) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }

    function _updateFirstLast(element, result) {
      // The first tabbable is the first node with tabindex 1 or 0.
      // The last tabbable is the last node with tabindex 0.
      var tabIndex = Math.max(element.tabIndex, 0);
      var first = result[0];
      var last = result[1];
      if (!first) {
        // First insertion into the result.
        result.push(element);
      } else if (first.tabIndex !== 1 && tabIndex === 1) {
        // A new first!
        result.splice(0, 1, element);
      } else if (!last) {
        // Second insertion into the result.
        result.push(element);
      } else if (tabIndex === 0 || (last.tabindex > 0 && last.tabindex < tabIndex)) {
        // A new last!
        result.splice(1, 1, element);
      }
    }

    /**
     * Returns if a element is focusable.
     * @param {!HTMLElement} element
     * @return {boolean}
     */
    function isFocusable(element) {
      // From http://stackoverflow.com/a/1600194/4228703:
      // There isn't a definite list, it's up to the browser. The only
      // standard we have is DOM Level 2 HTML https://www.w3.org/TR/DOM-Level-2-HTML/html.html,
      // according to which the only elements that have a focus() method are
      // HTMLInputElement,  HTMLSelectElement, HTMLTextAreaElement and
      // HTMLAnchorElement. This notably omits HTMLButtonElement and
      // HTMLAreaElement.
      // Referring to these tests with tabbables in different browsers
      // http://allyjs.io/data-tables/focusable.html

      // Elements that cannot be focused if they have [disabled] attribute.
      if (matches.call(element, 'input, select, textarea, button, object')) {
        return matches.call(element, ':not([disabled])');
      }
      // Elements that can be focused even if they have [disabled] attribute.
      return matches.call(element,
        'a[href], area[href], iframe, [tabindex], [contentEditable]');
    }
    /**
     * Returns false if the element has `visibility: hidden` or `display: none`
     * @param {!HTMLElement} element
     * @return {boolean}
     * @private
     */
    function _isVisible(element) {
      // Check inline style first to save a re-flow. If looks good, check also
      // computed style.
      var style = element.style;
      if (style.visibility !== 'hidden' && style.display !== 'none') {
        style = window.getComputedStyle(element);
        return (style.visibility !== 'hidden' && style.display !== 'none');
      }
      return false;
    }
    /**
     * Returns the normalized element tabindex. If not focusable, returns -1.
     * It checks for the attribute "tabindex" instead of the element property
     * `tabIndex` since browsers assign different values to it.
     * e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`
     * @param {!HTMLElement} element
     * @return {!number}
     * @private
     */
    function _normalizedTabIndex(element) {
      if (isFocusable(element) && _isVisible(element)) {
        var tabIndex = element.getAttribute('tabindex') || 0;
        return Number(tabIndex);
      }
      return -1;
    }

    /**
     * Returns if a element is tabbable. To be tabbable, a element must be
     * focusable, visible, and with a tabindex !== -1.
     * @param {!HTMLElement} element
     * @return {boolean}
     */
    function isTabbable(element) {
      return _normalizedTabIndex(element) >= 0;
    }

  })();
</script>