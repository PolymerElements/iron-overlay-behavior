<!doctype html>
<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->
<html>
  <head>

    <title>iron-overlay-behavior tests</title>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1, user-scalable=yes">

    <script src="../../webcomponentsjs/webcomponents-lite.js"></script>

    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../../iron-test-helpers/iron-test-helpers.html">
    <link rel="import" href="test-overlay.html">

  </head>
  <body>

    <test-fixture id="basic">
      <template>
        <test-overlay>
          Basic Overlay
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="opened">
      <template>
        <test-overlay opened>
          Basic Overlay
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="autofocus">
      <template>
        <test-overlay>
          Autofocus
          <button autofocus>button</button>
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="multiple">
      <template>
        <test-overlay class="overlay-1">
          Overlay 1
        </test-overlay>
        <test-overlay class="overlay-2">
          Overlay 2
        </test-overlay>
        <test-overlay class="overlay-3">
          Overlay 3
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="backdrop-multiple">
      <template>
        <test-overlay with-backdrop class="overlay-1">
          Overlay 1 with backdrop
        </test-overlay>
        <test-overlay with-backdrop class="overlay-2">
          Overlay 2 with backdrop
        </test-overlay>
        <test-overlay with-backdrop class="overlay-3">
          Overlay 3 with backdrop
        </test-overlay>
      </template>
    </test-fixture>

    <test-fixture id="backdrop-parent">
      <template>
        <test-overlay with-backdrop>
          <test-overlay with-backdrop>
            Overlay 2
          </test-overlay>
        </test-overlay>
      </template>
    </test-fixture>

    <script>

      function runAfterOpen(overlay, cb) {
        overlay.addEventListener('iron-overlay-opened', function() {
          Polymer.Base.async(cb, 1);
        });
        overlay.open();
      }

      suite('basic overlay tests', function() {
        var overlay;

        setup(function() {
          overlay = fixture('basic');
        });

        test('overlay starts hidden', function() {
          assert.isFalse(overlay.opened, 'overlay starts closed');
          assert.equal(getComputedStyle(overlay).display, 'none', 'overlay starts hidden');
        });

        test('overlay open by default', function(done) {
          overlay = fixture('opened');
          overlay.addEventListener('iron-overlay-opened', function() {
            assert.isTrue(overlay.opened, 'overlay starts opened');
            assert.notEqual(getComputedStyle(overlay).display, 'none', 'overlay starts showing');
            done();
          });
        });

        test('overlay positioned & sized properly', function(done) {
          overlay = fixture('opened');
          overlay.addEventListener('iron-overlay-opened', function() {
            var s = getComputedStyle(overlay);
            assert.isTrue(parseFloat(s.left) === (window.innerWidth - overlay.offsetWidth)/2, 'centered horizontally');
            assert.isTrue(parseFloat(s.top) === (window.innerHeight - overlay.offsetHeight)/2, 'centered vertically');
            done();
          });
        });

        test('overlay open/close events', function(done) {
          var nevents = 0;

          overlay.addEventListener('iron-overlay-opened', function() {
            nevents += 1;
            overlay.opened = false;
          });

          overlay.addEventListener('iron-overlay-closed', function() {
            nevents += 1;
            assert.equal(nevents, 2, 'opened and closed events fired');
            done();
          });

          overlay.opened = true;
        });

        test('open overlay refits on iron-resize', function() {
          var overlay = fixture('opened');
          var spy = sinon.spy(overlay, 'refit');
          overlay.fire('iron-resize');
          assert.isTrue(spy.called, 'overlay should refit');
        });

        test('closed overlay does not refit on iron-resize', function() {
          var spy = sinon.spy(overlay, 'refit');
          overlay.fire('iron-resize');
          assert.isFalse(spy.called, 'overlay should not refit');
        });

        test('open() triggers iron-resize', function(done) {
          // Skip potential `iron-resize` from window resizing
          setTimeout(function () {
            var spy = sinon.stub();
            overlay.addEventListener('iron-resize', spy);
            runAfterOpen(overlay, function () {
              assert.isTrue(spy.calledOnce, 'iron-resize should be called once');
              done();
            });
          });
        });

        test('closed overlay does not trigger iron-resize when its content changes', function(done) {
          // Skip potential `iron-resize` from window resizing
          setTimeout(function () {
            var spy = sinon.stub();
            overlay.addEventListener('iron-resize', spy);
            var child = document.createElement('div');
            child.innerHTML = 'hi';
            Polymer.dom(overlay).appendChild(child);
            overlay.async(function () {
              assert.isFalse(spy.called, 'iron-resize should not be called');
              done();
            }, 10);
          });
        });

        test('open overlay triggers iron-resize when its content changes', function(done) {
          runAfterOpen(overlay, function () {
            var spy = sinon.stub();
            overlay.addEventListener('iron-resize', spy);
            var child = document.createElement('div');
            child.innerHTML = 'hi';
            Polymer.dom(overlay).appendChild(child);
            overlay.async(function () {
              assert.isTrue(spy.calledOnce, 'iron-resize should be called once');
              done();
            }, 10);
          });
        });

        test('close an overlay quickly after open', function(done) {
          // first, open the overlay
          overlay.open();
          overlay.async(function() {
            // during the opening transition, close the overlay
            this.close();
            // wait for any exceptions to be thrown until the transition is done
            this.async(function() {
              done();
            }, 300);
          });
        });

        test('close an overlay in proximity to another overlay', function(done) {
          var secondOverlay = fixture('basic');
          // Open and close a separate overlay.
          secondOverlay.open();
          secondOverlay.close();

          // Open the overlay we care about.
          overlay.open();

          // Wait for infinite recursion, otherwise we win:
          overlay.addEventListener('iron-overlay-closed', function() {
            done();
          });

          // Immediately close the first overlay:
          overlay.close();
        });

        test('clicking an overlay does not close it', function(done) {
          runAfterOpen(overlay, function() {
            var spy = sinon.stub();
            overlay.addEventListener('iron-overlay-closed', spy);
            overlay.fire('click');
            setTimeout(function() {
              assert.isFalse(spy.called, 'iron-overlay-closed should not fire');
              done();
            }, 10);
          });
        });

        test('node with autofocus is focused', function(done) {
          overlay = fixture('autofocus');
          runAfterOpen(overlay, function() {
            assert.equal(Polymer.dom(overlay).querySelector('[autofocus]'), document.activeElement, '<button autofocus> is focused');
            done();
          });
        });

        test('cancel an overlay by clicking outside', function(done) {
          runAfterOpen(overlay, function() {
            overlay.addEventListener('iron-overlay-canceled', function(event) {
              done();
            });
            MockInteractions.tap(document.body);
          });
        });

        test('close an overlay by clicking outside', function(done) {
          runAfterOpen(overlay, function() {
            overlay.addEventListener('iron-overlay-closed', function(event) {
              assert.isTrue(event.detail.canceled, 'overlay is canceled');
              done();
            });
            MockInteractions.tap(document.body);
          });
        });

        test('cancel event can be prevented', function(done) {
          runAfterOpen(overlay, function() {
            overlay.addEventListener('iron-overlay-canceled', function(event) {
              event.preventDefault();
            });
            var spy = sinon.stub();
            overlay.addEventListener('iron-overlay-closed', spy);
            MockInteractions.tap(document.body);
            setTimeout(function() {
              assert.isFalse(spy.called, 'iron-overlay-closed should not fire');
              done();
            }, 10);
          });
        });

        test('cancel an overlay with esc key', function(done) {
          runAfterOpen(overlay, function() {
            overlay.addEventListener('iron-overlay-canceled', function(event) {
              done();
            });
            fireEvent('keydown', {
              keyCode: 27
            }, document);
          });
        });

        test('close an overlay with esc key', function(done) {
          runAfterOpen(overlay, function() {
            overlay.addEventListener('iron-overlay-closed', function(event) {
              assert.isTrue(event.detail.canceled, 'overlay is canceled');
              done();
            });
            fireEvent('keydown', {
              keyCode: 27
            }, document);
          });
        });

        test('no-cancel-on-outside-click property', function(done) {
          overlay.noCancelOnOutsideClick = true;
          runAfterOpen(overlay, function() {
            var spy = sinon.stub();
            overlay.addEventListener('iron-overlay-closed', spy);
            MockInteractions.tap(document.body);
            setTimeout(function() {
              assert.isFalse(spy.called, 'iron-overlay-closed should not fire');
              done();
            }, 10);
          });
        });

        test('no-cancel-on-esc-key property', function(done) {
          overlay.noCancelOnEscKey = true;
          runAfterOpen(overlay, function() {
            var spy = sinon.stub();
            overlay.addEventListener('iron-overlay-closed', spy);
            fireEvent('keydown', {
              keyCode: 27
            }, document);
            setTimeout(function() {
              assert.isFalse(spy.called, 'iron-overlay-cancel should not fire');
              done();
            }, 10);
          });
        });

      });

      suite('multiple overlays', function() {
        var overlays;

        setup(function() {
          overlays = fixture('multiple');
        });

        test('new overlays appear on top', function(done) {
          runAfterOpen(overlays[0], function() {
            runAfterOpen(overlays[1], function() {
              var styleZ = parseInt(window.getComputedStyle(overlays[0]).zIndex, 10);
              var styleZ1 = parseInt(window.getComputedStyle(overlays[1]).zIndex, 10);
              assert.isTrue(styleZ1 > styleZ, 'overlays[1] has higher z-index than overlays[0]');
              done();
            });
          });
        });

        test('ESC closes only one opened overlay', function(done) {
          runAfterOpen(overlays[0], function() {
            runAfterOpen(overlays[1], function() {
              // keydown is sync, keyup async (but no need to wait for it).
              MockInteractions.pressAndReleaseKeyOn(document.body, 27);
              // Ideally overlays[1] should be closed and overlays[0] still open,
              // but in this test env overlays[0]._onCaptureKeydown gets called before
              // overlays[1]._onCaptureKeydown.
              // TODO investigate if this is because of CustomEvents in MockInteractions.
              var opened0 = overlays[0].opened && !overlays[1].opened;
              var opened1 = !overlays[0].opened && overlays[1].opened;
              assert.isTrue(opened0 || opened1, 'only one overlay is still opened');
              done();
            });
          });
        });
      });

      suite('z-ordering', function() {

        var overlays;
        var originalMinimumZ;

        setup(function() {
          overlays = fixture('multiple');
          originalMinimumZ = Polymer.IronOverlayManager._minimumZ;
        });

        teardown(function() {
          Polymer.IronOverlayManager._minimumZ = originalMinimumZ;
        });

        // for iframes
        test('default z-index is greater than 100', function(done) {
          runAfterOpen(overlays[0], function() {
            var styleZ = parseInt(window.getComputedStyle(overlays[0]).zIndex, 10);
            assert.isTrue(styleZ > 100, 'overlays[0] z-index is <= 100');
            done();
          });
        });

        test('ensureMinimumZ() effects z-index', function(done) {
          Polymer.IronOverlayManager.ensureMinimumZ(1000);

          runAfterOpen(overlays[0], function() {
            var styleZ = parseInt(window.getComputedStyle(overlays[0]).zIndex, 10);
            assert.isTrue(styleZ > 1000, 'overlays[0] z-index is <= 1000');
            done();
          });
        });

        test('ensureMinimumZ() never decreases the minimum z-index', function(done) {
          Polymer.IronOverlayManager.ensureMinimumZ(1000);
          Polymer.IronOverlayManager.ensureMinimumZ(500);

          runAfterOpen(overlays[0], function() {
            var styleZ = parseInt(window.getComputedStyle(overlays[0]).zIndex, 10);
            assert.isTrue(styleZ > 1000, 'overlays[0] z-index is <= 1000');
            done();
          });
        });

      });

      suite('overlays with backdrop', function() {
        var overlay;

        setup(function() {
          overlay = fixture('backdrop-multiple')[0];
        });

        test('backdrop class added to the parent', function(done) {
          overlay.open();
          // Immediately added
          assert.isTrue(overlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop class added to parent');
          setTimeout(function() {
            assert.isTrue(overlay.parentNode.classList.contains('opened'), 'backdrop is opened');
            done();
          }, 10);
        });

        test('backdrop class removed if toggling open/close', function(done) {
          overlay.open();
          overlay.close();
          // Immediately added
          assert.isFalse(overlay.parentNode.classList.contains('open'), 'backdrop is closed');
          setTimeout(function() {
            assert.isFalse(overlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop class removed from parent');
            done();
          }, 210);
        });

        test('backdrop is removed when the element is removed from DOM', function(done) {
          runAfterOpen(overlay, function() {
            overlay.close();
            // Immediately removed
            assert.isFalse(overlay.parentNode.classList.contains('open'), 'backdrop is closed');
            // wait for animation
            setTimeout(function(){
              assert.isFalse(overlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop class removed from parent');
              done();
            }, 210);
          });
        });

        test('updating with-backdrop to false closes backdrop', function(done) {
          runAfterOpen(overlay, function() {
            overlay.withBackdrop = false;
            // Immediately removed
            assert.isFalse(overlay.parentNode.classList.contains('open'), 'backdrop is closed');
            // wait for animation
            setTimeout(function(){
              assert.isFalse(overlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop class removed from parent');
              done();
            }, 210);
          });
        });
      });

      suite('nested overlays with backdrop', function() {
        var outerOverlay, innerOverlay;

        setup(function() {
          outerOverlay = fixture('backdrop-parent');
          innerOverlay = outerOverlay.children[0];
        });

        test('innerOverlay and backdrop are siblings', function(done) {
          // Open both overlays
          outerOverlay.open();
          innerOverlay.open();
          setTimeout(function(){
            assert.isTrue(innerOverlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop added to innerOverlay parent');
            assert.isFalse(outerOverlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop removed from outerOverlay parent');
            done();
          }, 210);
        });

        test('backdrop gets moved to new parent after closing top overlay with backdrop', function(done) {
          // Open both overlays
          outerOverlay.open();
          runAfterOpen(innerOverlay, function () {
            innerOverlay.close();
            setTimeout(function(){
              assert.isTrue(outerOverlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop added to outerOverlay parent');
              assert.isFalse(innerOverlay.parentNode.classList.contains('iron-overlay-backdrop'), 'backdrop removed from innerOverlay parent');
              done();
            }, 210);
          });
        });
      });

      suite('a11y', function() {

        test('overlay has aria-hidden=true when opened', function() {
          var overlay = fixture('basic');
          assert.equal(overlay.getAttribute('aria-hidden'), 'true', 'overlay has aria-hidden="true"');
          overlay.open();
          assert.isFalse(overlay.hasAttribute('aria-hidden'), 'overlay does not have aria-hidden attribute');
          overlay.close();
          assert.equal(overlay.getAttribute('aria-hidden'), 'true', 'overlay has aria-hidden="true"');
        });

      })

    </script>

  </body>
</html>
