<!--
@license
Copyright (c) 2015 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
-->

<link rel="import" href="../polymer/polymer.html">

<style is="custom-style">

  :root .iron-overlay-backdrop::after {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background-color: var(--iron-overlay-backdrop-background-color, #000);
    opacity: 0;
    transition: opacity 0.2s;
    z-index: 200;

    @apply(--iron-overlay-backdrop);
  }

  :root .iron-overlay-backdrop.opened::after {
    opacity: var(--iron-overlay-backdrop-opacity, 0.6);
    @apply(--iron-overlay-backdrop-opened);
  }

</style>

<script>

  /**
   * @struct
   * @constructor
   */
  Polymer.IronOverlayManagerClass = function() {
    this._overlays = [];
    /**
     * iframes have a default z-index of 100, so this default should be at least
     * that.
     * @private {number}
     */
    this._minimumZ = 101;
    // there is space for 99 overlays without backdrop...
    this._minimumWithBackdropZ = 200;

    this._backdrops = [];
  }

  Polymer.IronOverlayManagerClass.prototype._applyOverlayZ = function(overlay, aboveZ) {
    this._setZ(overlay, aboveZ + 1);
  };

  Polymer.IronOverlayManagerClass.prototype._setZ = function(element, z) {
    element.style.zIndex = z;
  };

  /**
   * track overlays for z-index and focus managemant
   */
  Polymer.IronOverlayManagerClass.prototype.addOverlay = function(overlay) {
    var currentZ = this.currentOverlayZ();
    this._overlays.push(overlay);
    var newZ = this.currentOverlayZ();
    var minimumZ = Math.max(currentZ, (overlay.withBackdrop ? this._minimumWithBackdropZ : this._minimumZ));
    if (newZ <= minimumZ) {
      this._applyOverlayZ(overlay, minimumZ);
    }
  };

  Polymer.IronOverlayManagerClass.prototype.removeOverlay = function(overlay) {
    var i = this._overlays.indexOf(overlay);
    if (i >= 0) {
      this._overlays.splice(i, 1);
      this._setZ(overlay, '');
    }
  };

  Polymer.IronOverlayManagerClass.prototype.currentOverlay = function() {
    var i = this._overlays.length - 1;
    while (this._overlays[i] && !this._overlays[i].opened) {
      --i;
    }
    return this._overlays[i];
  };

  Polymer.IronOverlayManagerClass.prototype.currentOverlayZ = function() {
    return this._getOverlayZ(this.currentOverlay());
  };

  /**
   * Ensures that the minimum z-index of new overlays is at least `minimumZ`.
   * This does not effect the z-index of any existing overlays.
   *
   * @param {number} minimumZ
   */
  Polymer.IronOverlayManagerClass.prototype.ensureMinimumZ = function(minimumZ) {
    this._minimumZ = Math.max(this._minimumZ, minimumZ);
  };

  Polymer.IronOverlayManagerClass.prototype.focusOverlay = function() {
    var current = this.currentOverlay();
    // We have to be careful to focus the next overlay _after_ any current
    // transitions are complete (due to the state being toggled prior to the
    // transition). Otherwise, we risk infinite recursion when a transitioning
    // (closed) overlay becomes the current overlay.
    //
    // NOTE: We make the assumption that any overlay that completes a transition
    // will call into focusOverlay to kick the process back off. Currently:
    // transitionend -> _applyFocus -> focusOverlay.
    if (current && !current.transitioning) {
      current._applyFocus();
    }
  };

  Polymer.IronOverlayManagerClass.prototype.trackBackdrop = function(element) {
    // backdrops contains the overlays with a backdrop that are currently visible

    var oldParent = this._getBackdropParent();

    var index = this._backdrops.indexOf(element);
    if (element.opened && element.withBackdrop) {
      // no duplicates
      if (index === -1) {
        this._backdrops.push(element);
      }
    } else if (index >= 0) {
      this._backdrops.splice(index, 1);
    }

    var newParent = this._getBackdropParent();
    // if parent changed, update classes.
    if (newParent !== oldParent) {
      if (oldParent) {
        oldParent.classList.remove('opened');
        // wait for animations
        clearTimeout(oldParent._overlayTimeout);
        oldParent._overlayTimeout = setTimeout(function () {
          oldParent._overlayTimeout = null;
          oldParent.classList.remove('iron-overlay-backdrop');
        }, 200);
      }
      if (newParent) {
        newParent.classList.add('iron-overlay-backdrop');
        // wait a bit to trigger animations
        clearTimeout(newParent._overlayTimeout);
        newParent._overlayTimeout = setTimeout(function () {
          newParent._overlayTimeout = null;
          newParent.classList.add('opened');
        }, 1);
      }
    }
  };

  Polymer.IronOverlayManagerClass.prototype.getBackdrops = function() {
    return this._backdrops;
  };

  Polymer.IronOverlayManagerClass.prototype._getBackdropParent = function() {
    var element = this._backdrops[this._backdrops.length-1];
    var parent = element ? Polymer.dom(element).parentNode : null;
    // if parent is document fragments, it won't have classList defined
    // this can happen when element is not attached yet to the main document
    if (parent && !parent.classList) {
      parent = null;
    }
    return parent;
  };

  /**
   * Calculates the minimum z-index for the overlay.
   */
  Polymer.IronOverlayManagerClass.prototype._getOverlayZ = function(overlay) {
    var z = overlay && overlay.withBackdrop ? this._minimumWithBackdropZ : this._minimumZ;
    if (overlay) {
      var z1 = Number(window.getComputedStyle(overlay).zIndex);
      // Check if is a number
      // Number.isNaN not supported in IE 10+
      if (z1 === z1) {
        z = z1;
      }
    }
    return z;
  };

  Polymer.IronOverlayManager = new Polymer.IronOverlayManagerClass();

</script>
